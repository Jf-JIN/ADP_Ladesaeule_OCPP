## 基本架构

系统分为

* 端口
  * websocket 模块
  * ocpp充电桩模块
  * 网页GUI端口
* 系统
  * 底层硬件驱动
  * 硬件管理模块
  * 顶层逻辑层
  * 网页服务器

## 通讯

端口通讯：

* 由于ocpp是基于websocket通讯的，所以其中一个通讯端口为websocket。
* HTTP协议，用于网页服务端通讯，处理网页访问请求，以及网页显示

系统内部通讯：使用信号机制

### 信号机制

来源：Qt

基于Qt而自实现，功能相比于Qt少很多，信号和槽的连接是同步执行的，也就是哪里调用哪里运行，和Qt的跨线程信号机制不同。（设计模式：观察者模式变体)

优点：

* 函数解耦，模块间完全独立，互不影响

* 灵活性，运行过程中可以随时断开连接，也可以随时连接，可以一对多也可以多对一

缺点：

* 运行速度会稍稍慢点，慢的部分在于需要管理槽函数，比如激活时会使用for循环，for循环会相对占用一点时间和空间，但在信号连接量不大的情况下，可以忽略这个运行速度和内存空间占用的问题
* 调试时比回调函数难以定位，因为信号属于隐式调用(动态调用)，相比于回调函数的显式定义，难以在调试时知道哪里调用的。  

## 协程隔离

* 原因：

由于python中如果使用异步编程关键字 await，则一定要在async 关键字下定义函数，那么被async关键字定义的函数想要被调用的话，就一定要使用await。这样整个系统从使用await关键的函数向上都必须是异步编程，这样整个系统都是异步编程，如果系统想写GUi或者和其他需要同步编程的模块共同使用的话，比较麻烦。同时由于异步编程执行顺序不固定，对于一些时序敏感的模块来说，容易造成隐性故障，且难以及时报错。调试时难以发现错误。所以该系统倾向于使用同步编程。然而Ocpp库和websocket本身是使用异步编程的，需要使用协程进行工作，所以该系统采用大部分是同步编程，异步编程作为协作，通过信号来连接各模块，异步只在充电桩监听端口使用。发送端口需要进行协程隔离。

* 方法：生产者-消费者 模式 + 观察者模式

发送端口使用生产者消费者模式，建立一个队列，并监听此队列，该对象暴露给外面的发送函数是将消息放入队列中，发送端口监听过程中发现队列中有消息，则读取消息并发送。在此过程中使用队列这个中间者，将生产者(系统，同步编程)和消费者(端口，异步编程)隔离开，同时可以增加对两者的执行速度不同的包容和缓冲。接收端口使用观察者模式的变体——自定义信号，将收到的消息通过信号向外发送。这样就实现了同步和异步的隔离。



##### 异步和同步

协程相比于线程的最大好处在于可以在用户态单线程调整代码的执行调度，可以实现单线程应对高IO需求的情况，不必开多个线程或进程，节省资源。

## 端口隔离

ocpp使用的是监听和发送是一体的，在一个函数中接收消息并返回发送消息。其好处在于简单易用，但缺点在于难以扩展，如果充电桩ocpp模块只是整个系统的诸多重要部分之一的话，那么他将会和其他模块很难共用，他必须在顶层被使用不能存在同级或更高级别的调用或协作。那么这将会增加他和其他模块的耦合度。

将端口和逻辑模块进行隔离可以减低各模块和ocpp模块间的耦合度，也符合单一功能原则SRP。而且当系统想兼容其他协议时，代码逻辑可以复用而无需再次写相同的调用逻辑，只需要重定义发送的消息就可以。但缺点则是相对复杂。

* 方法：

  ......

## 充电逻辑

....



## 测试

#### 软件仿真模拟

充电桩电压高，直接测试并不安全，所以有必要使用软件进行仿真模拟

仿真的部分主要是Modbus控制的部分，所以可以将原来代码中操作modbus读写的部分改为对文件的读写操作。这样就可以先验证充电逻辑了，仿真模拟软件模仿实际EVSE的行为，并模拟显示EVSE的状态。

#### 实际硬件测试









